Lugar = "Escuela"
) -> escuela
data.frame(
Edad = rnorm(45, 15, 1.9),
Lugar = "Preparatoria"
) -> prepa
data.frame(
Edad = rnorm(80, 21, 2.5),
Lugar = "Universidad"
) -> universidad
rbind(escuela, prepa, universidad) -> edad_lugar
boxplot(Edad ~ Lugar, data = edad_lugar)
X <-seq(0, 3*pi, length.out = 100)
Y <- -0.3*X + 1 + rnorm(100,0,0.5)
Z <- -0.3*X + 1
data.frame(X,Y,Z) -> datos_lineal
plot(Y ~ X, data = datos_lineal )
lines(Z ~ X, data = datos_lineal, col = 2, lwd = 2)
# Modelo no lineal
X <-seq(0, 3*pi, length.out = 100)
Y <- cos(x) + rnorm(100,0,0.5)
# Modelo no lineal
X <- seq(0, 3*pi, length.out = 100)
Y <- cos(X) + rnorm(100,0,0.5)
Z <- data.frame(X,Y,Z) -> datos_no_lineal + 1
Z <- cos(X)
data.frame(X,Y,Z) -> datos_no_lineal
plot(Y ~ X, data = datos_no_lineal )
lines(Z ~ X, data = datos_no_lineal, col = 2, lwd = 2)
setwd("~/cursos/Curso_de_Estadistica_Inferencial_con_R/Scripts_estadistica_inferencial")
setwd("~/cursos/Curso_de_Estadistica_Inferencial_con_R/Scripts_estadistica_inferencial")
tamano_muestral <- 35
iteraciones <- 100
medias <- vector()
desv_est <- vector()
media_poblacional <- 3
desv_est_poblacional <- 5
for(i in seq_len(iteraciones)){
muestra <- rnorm(tamano_muestral, media_poblacional, desv_est_poblacional)
medias[i] <- mean(muestra)
desv_est[i] <- sd(muestra)
}
plot(medias, desv_est)
points(media_poblacional, desv_est_poblacional, col = 2, cex = 2, pch = 20)
tamano_muestral <- 35
iteraciones <- 100
minimo_poblacional <- 3
maximo_poblacional <- 8
minimos <- vector()
maximos <- vector()
for(i in seq_len(iteraciones)){
muestra <- runif(tamano_muestral, minimo_poblacional, maximo_poblacional)
minimos[i] <- min(muestra)
maximos[i] <- max(muestra)
}
plot(minimos, maximos)
points(minimo_poblacional, maximo_poblacional, col = 2, cex = 2, pch = 20)
tamano_muestral <- 35
iteraciones <- 100
beta_0 <- 1
beta_1 <- -0.3
beta_0_estimado <- vector()
beta_1_estimado <- vector()
genera_y <- function(x, beta_0, beta_1){
beta_1*x + beta_0 + rnorm(length(x), 0, 0.5)
}
for(i in seq_len(iteraciones)){
X <- seq(-3, 3, length.out = tamano_muestral)
Y <- genera_y(X, beta_0, beta_1)
betas_estimados <- coef(lm(Y ~ X))
#lm funcion linear model de R
beta_0_estimado[i] <- betas_estimados[1]
beta_1_estimado[i] <- betas_estimados[2]
}
plot(beta_0_estimado, beta_1_estimado)
points(beta_0, beta_1, col = 2, cex = 2, pch = 20)
minimo_poblacional <- 3
maximo_poblacional <- 8
tibble(
muestras = replicate(iteraciones, runif(tamano_muestral, minimo_poblacional, maximo_poblacional), simplify = FALSE),
a = map_dbl(muestras, min),
b = map_dbl(muestras, max)
) -> simulaciones
library(tibble)
tibble(
muestras = replicate(iteraciones, runif(tamano_muestral, minimo_poblacional, maximo_poblacional), simplify = FALSE),
a = map_dbl(muestras, min),
b = map_dbl(muestras, max)
) -> simulaciones
library("dplyr")
library("ggplot2")
library("magrittr")
library("purrr")
tibble(
muestras = replicate(iteraciones, runif(tamano_muestral, minimo_poblacional, maximo_poblacional), simplify = FALSE),
a = map_dbl(muestras, min),
b = map_dbl(muestras, max)
) -> simulaciones
colores_platzi <- c("#78D92A", "#002E4E", "#058ECD", "#ED2B05", "#F4F7F4")
tamano_muestral <- 35
iteraciones <- 100
minimo_poblacional <- 3
maximo_poblacional <- 8
View(simulaciones)
View(simulaciones)
qplot(a, b, data = simulaciones) +
annotate("point", 3, 8, colour = colores_platzi[3], size = 5) +
theme_minimal()
beta_0 <- 1
beta_1 <- -0.3
estima_betas <- function(x, y){
coef(lm(y ~ x))
tibble(
datos_x = replicate(iteraciones, seq(-3, 3, length.out = tamano_muestral), simplify = FALSE),
datos_y = map(datos_x, genera_y, beta_0, beta_1),
betas = map2(datos_x, datos_y, estima_betas),
beta_0 = map_dbl(betas, extract, 1),
beta_1 = map_dbl(betas, extract, 2),
# plot = map2(datos_x, datos_y, plot)
) -> simulaciones
qplot(beta_0, beta_1, data = simulaciones) +
annotate("point", 1, -0.3, colour = colores_platzi[3], size = 5) +
theme_minimal()
qplot(beta_0, beta_1, data = simulaciones) +
annotate("point", 1, -0.3, colour = colores_platzi[3], size = 5) +
theme_minimal()
tamano_muestral <- 35
iteraciones <- 100
media_poblacional_A <- 5
media_poblacional_B <- 3
plot(media_poblacional_A, media_poblacional_B)
plot(media_poblacional_A, media_poblacional_B)
plot(media_poblacional_A, media_poblacional_B)
tamano_muestral <- 35
iteraciones <- 100
media_poblacional_A <- 5
media_poblacional_B <- 3
desv_est_poblacional <- 2
plot(media_poblacional_A, media_poblacional_B)
plot(media_poblacional_A, media_poblacional_B)
dev.off()
plot(media_poblacional_A, media_poblacional_B)
plot(media_poblacional_A, media_poblacional_B)
plot(media_poblacional_A, media_poblacional_B)
tamano_muestral <- 35
iteraciones <- 100
media_poblacional_A <- 5
media_poblacional_B <- 3
desv_est_poblacional <- 2
plot(media_poblacional_A, media_poblacional_B)
for(i in seq_len(iteraciones)){
#obtengo la muestra de A
muestra_A <- rnorm(tamano_muestral, media_poblacional_A, desv_est_poblacional)
# Aplico funcion t de student que obtiene datos sobre la media
t_test_A <- t.test(muestra_A)
# Cambio el intervalo de confianza de A
intervalo_A <- t_test_A$conf.int
# Obtengo limites del intervalo
LI_A <- min(intervalo_A)
LS_A <- max(intervalo_A)
# Obtengo la muestra de B
muestra_B <- rnorm(tamano_muestral, media_poblacional_B, desv_est_poblacional)
t_test_B <- t.test(muestra_B)
intervalo_B <- t_test_B$conf.int
LI_B <- min(intervalo_B)
LS_B <- max(intervalo_B)
# Creo un rectangulo con los limites de A y B
rect(LI_A, LI_B, LS_A, LS_B)
}
abline(0,1, col = 2)
points(media_poblacional_A, media_poblacional_B, col = 4, pch = 20, cex = 3)
tamano_muestral <- 350  #35
for(i in seq_len(iteraciones)){
#obtengo la muestra de A
muestra_A <- rnorm(tamano_muestral, media_poblacional_A, desv_est_poblacional)
# Aplico funcion t de student que obtiene datos sobre la media
t_test_A <- t.test(muestra_A)
# Cambio el intervalo de confianza de A
intervalo_A <- t_test_A$conf.int
# Obtengo limites del intervalo
LI_A <- min(intervalo_A)
LS_A <- max(intervalo_A)
# Obtengo la muestra de B
muestra_B <- rnorm(tamano_muestral, media_poblacional_B, desv_est_poblacional)
t_test_B <- t.test(muestra_B)
intervalo_B <- t_test_B$conf.int
LI_B <- min(intervalo_B)
LS_B <- max(intervalo_B)
# Creo un rectangulo con los limites de A y B
rect(LI_A, LI_B, LS_A, LS_B)
}
abline(0,1, col = 2)
points(media_poblacional_A, media_poblacional_B, col = 4, pch = 20, cex = 3)
tamano_muestral_max <- 500
iteraciones <- 100
media_poblacional <- 5
desv_est_poblacional <- 3
tamano_muestral <- floor(seq(10, tamano_muestral_max, length.out = iteraciones))
tamano_muestral
#inicializa vectores
desv_est_estimada <- media_estimada <- dif_cuad_media <- dif_cuad_desv_est <- vector()
desv_est_estimada
for (i in seq_len(iteraciones)) {
muestra <- rnorm(tamano_muestral[i], media_poblacional, desv_est_poblacional)
media_estimada[i] <- mean(muestra)
desv_est_estimada[i] <- sd(muestra)
dif_cuad_media[i] <- (media_estimada[i] - media_poblacional)^2
dif_cuad_desv_est[i] <- (desv_est_estimada[i] - desv_est_poblacional)^2
}
# Graficamos par la media_estimada vs temano_muestral
plot(media_estimada ~ tamano_muestral)
abline(h = media_poblacional, col = 2, lwd = 2)
plot(dif_cuad_media ~ tamano_muestral, type = "l")
# Graficamos par la desv_est_estimada vs temano_muestral
plot(desv_est_estimada ~ tamano_muestral)
abline(h = desv_est_poblacional, col = 2, lwd = 2)
plot(dif_cuad_desv_est ~ tamano_muestral, type = "l")
tamano_muestral <- 100
media <- 5
desv <- 3
iteraciones <- 75
x <- seq(-5, 15, length.out = 100)
x
Y <- rnorm(tamano_muestral, media, desv)
Y
estimador_kernel <- density(Y)
plot(estimador_kernel)
lines(x = x, y = dnorm(x, media, desv), col = 2, lwd = 2)
lines(x, dunif(x, media, desv), col = 2, lwd = 2)
lines(x, dunif(x, desv, media), col = 2, lwd = 2)
plot(estimador_kernel)
for(i in seq_len(iteraciones)){
Y <- rnorm(tamano_muestral, media, desv)
estimador_kernel <- density(Y)
lines(estimador_kernel)
}
lines(x = x, y = dnorm(x, media, desv), col = 2, lwd = 2)
tamano_muestral <- 100
a <- 3
b <- 8
iteraciones <- 75
x <- seq(2, 9, length.out = 100)
Y <- runif(tamano_muestral, a, b)
estimador_kernel <- density(Y)
plot(estimador_kernel)
lines(x = x, y = dunif(x, a, b), col = 2, lwd = 2)
plot(estimador_kernel)
for(i in seq_len(iteraciones)){
Y <- runif(tamano_muestral, a, b)
estimador_kernel <- density(Y)
lines(estimador_kernel)
}
lines(x = x, y = dunif(x, a, b), col = 2, lwd = 2)
tamano_muestral <- 100
media <- 5
desv <- 3
iteraciones <- 75
x <- seq(-5, 15, length.out = 100)
Y <- rnorm(tamano_muestral, media, desv)
estimador_ecdf <- ecdf(Y)
plot(estimador_ecdf, pch = "", verticals = TRUE)
lines(x = x, y = pnorm(x, media, desv), col = 2, lwd = 2)
plot(estimador_ecdf, pch = "", verticals = TRUE)
for(i in seq_len(iteraciones)){
Y <- rnorm(tamano_muestral, media, desv)
estimador_ecdf <- ecdf(Y)
lines(estimador_ecdf, pch = "", verticals = TRUE)
}
lines(x = x, y = pnorm(x, media, desv), col = 2, lwd = 2)
tamano_muestral <- 1000
a <- 2
b <- 8
iteraciones <- 75
x <- seq(-5, 15, length.out = 100)
Y <- runif(tamano_muestral, a, b)
estimador_ecdf <- ecdf(Y)
plot(estimador_ecdf, pch = "", verticals = TRUE)
lines(x = x, y = punif(x, a, b), col = 2, lwd = 2)
plot(estimador_ecdf, pch = "", verticals = TRUE)
for(i in 1:iteraciones){
Y <- runif(tamano_muestral, a, b)
estimador_ecdf <- ecdf(Y)
lines(estimador_ecdf, pch = "", verticals = TRUE)
}
lines(x = x, y = punif(x, a, b), col = 2, lwd = 2)
library("nnet")
iteraciones <- 50
tamano_muestral <- 23
genera_y <- function(x){
cos(x) + rnorm(length(x),0,0.5)
}
X <- seq(0, 3*pi, length.out = tamano_muestral)
Y <- genera_y(X)
plot(Y~X)
lines(cos(X)~X, col=2, lwd=2)
red_neuronal <- nnet(X, Y, size = 6, linout = TRUE, trace = FALSE)
YY <- predict(red_neuronal)
lines(YY~X, col=4, lwd=2)
plot(Y~X)
for (i in seq_len(iteraciones)) {
Y <- genera_y(X)
red_neuronal <- nnet(X, Y, size = 6, linout = TRUE, trace = FALSE)
YY <- predict(red_neuronal)
lines(YY~X, col=4, lwd=2)
}
lines(cos(X)~X, col=2, lwd=2)
iteraciones <- 150
tamano_muestral <- 200
genera_y <- function(x){
cos(x) + rnorm(length(x),0,0.5)
}
X <- seq(0, 3*pi, length.out = tamano_muestral)
Y <- genera_y(X)
plot(Y~X)
lines(cos(X)~X, col=2, lwd=2)
red_neuronal <- nnet(X, Y, size = 6, linout = TRUE, trace = FALSE)
YY <- predict(red_neuronal)
lines(YY~X, col=4, lwd=2)
plot(Y~X)
for (i in seq_len(iteraciones)) {
Y <- genera_y(X)
red_neuronal <- nnet(X, Y, size = 6, linout = TRUE, trace = FALSE)
YY <- predict(red_neuronal)
lines(YY~X, col=4, lwd=2)
}
lines(cos(X)~X, col=2, lwd=2)
iteraciones <- 100
tamano_muestral <- 30
beta_0 <- 1
beta_1 <- -0.3
x <- seq(-3, 3, length.out = tamano_muestral)
genera_y <- function(x, beta_0, beta_1){
beta_1*x + beta_0 + rnorm(length(x), 0, 0.5)
y <- genera_y(x, beta_0, beta_1)
modelo_lineal <- lm(y~x)
plot(x, y)
abline(beta_0, beta_1, col = 2, lwd = 2)
lines(x, modelo_lineal$fitted.values, col = 4, lwd = 2)
plot(x, modelo_lineal$fitted.values, type = "l")
for(i in seq_len(iteraciones)){
y <- genera_y(x, beta_0, beta_1)
modelo_lineal <- lm(y~x)
lines(x, modelo_lineal$fitted.values)
}
abline(beta_0, beta_1, col = 2, lwd = 2)
plot(x, modelo_lineal$fitted.values, type = "l")
plot(x, modelo_lineal$fitted.values, type = "l")
tamano_muestral <- 7000
media <- 5.5
desv_est <- 2
iteraciones <- 100
x <- seq(2, 9, length.out = 100)
Y <- rnorm(tamano_muestral, media, desv_est)
estimador_kernel <- density(Y)
plot(estimador_kernel)
lines(x = x, y = dnorm(x, media, desv_est), col = 2, lwd = 2)
plot(estimador_kernel)
for(i in seq_len(iteraciones)){
Y <- rnorm(tamano_muestral, media, desv_est)
estimador_kernel <- density(Y)
lines(estimador_kernel)
}
lines(x = x, y = dnorm(x, media, desv_est), col = 2, lwd = 2)
tamano_muestral <- 7000
a <- 3
b <- 8
iteraciones <- 75
x <- seq(2, 9, length.out = 100)
Y <- runif(tamano_muestral, a, b)
estimador_kernel <- density(Y)
plot(estimador_kernel)
lines(x = x, y = dunif(x, a, b), col = 2, lwd = 2)
plot(estimador_kernel)
for(i in seq_len(iteraciones)){
Y <- runif(tamano_muestral, a, b)
estimador_kernel <- density(Y)
lines(estimador_kernel)
}
lines(x = x, y = dunif(x, a, b), col = 2, lwd = 2)
tamano_muestral <- 23
iteraciones <- 1000
beta_0 <- 1
beta_1 <- -0.3
desv_est_error <- 0.5
genera_x <- function(n) seq(-3, 3, length.out = n)
genera_y <- function(x, beta_0, beta_1){
beta_1*x + beta_0 + rnorm(length(x), 0, desv_est_error)
}
#los datos se vuelven fijos para el ejercicio
datos_x <- geno_muestral)
#los datos se vuelven fijos para el ejercicio
datos_x <- genera_x(tamano_muestral)
datos_y <- genera_y(datos_x, beta_0, beta_1)
#hacemos la regresion con lm (linear model)
lm(datos_y ~ datos_x) -> modelo
coefficients(modelo) -> coeficientes_muestrales
# obtenemos intervalos de confianza con confint
confint(modelo)
#inicializamos vectores
beta_0_estimado <- beta_1_estimado <- vector()
for(i in seq_len(iteraciones)){
# Tomamos una muesta con sample(numeros, tamaño, reemplazo(datos repetidos)
muestra <- sample(seq_along(datos_x), length(datos_x), replace = TRUE)
# Usando los valores aleatorios y repetitivos de la variable "muestra"
# como indices tomamos una muestra datos de la variable "datos_x"
muestra_x <- datos_x[muestra]
# Repetimos el procedimiento para muestra_y
muestra_y <- datos_y[muestra]
# Hacemos un modelo lineal de con las submuestras
lm(muestra_y ~ muestra_x) -> modelo
# Obtenemos sus coeficientes
coeficientes <- coefficients(modelo)
# Guardamos los coeficientes estimados
beta_0_estimado[i] <- coeficientes[1]
beta_1_estimado[i] <- coeficientes[2]
}
data.frame(
limite = c("inferior", "superior"),
beta_0 = quantile(beta_0_estimado, c(0.025, 0.975)),
beta_1 = quantile(beta_1_estimado, c(0.025, 0.975))
) -> intervalo_bootstrapping
intervalo_bootstrapping
# Hacemos el plot
plot(beta_0, beta_1)
points(beta_0_estimado, beta_1_estimado)
points(coeficientes_muestrales[1], coeficientes_muestrales[2], pch = 20, col = 4, cex = 3)
points(beta_0, beta_1, pch = 20, col = 2, cex = 3)
rect(
intervalo_bootstrapping$beta_0[1],
intervalo_bootstrapping$beta_1[1],
intervalo_bootstrapping$beta_0[2],
intervalo_bootstrapping$beta_1[2],
border = 4, lwd = 2)
library("caret")
library("parallel")
install.packages("caret")
library("nnet")
library("parallel")
rmse_fold <- function(pliegue, form, datos,  nn_size){
# preguntamos cuales de las filas que tenemos en nuestros datos estan en el vector pliegue
pliegue_logic <- seq_len(nrow(datos)) %in% pliegue
# Definimos los sets datos
prueba <- subset(datos, pliegue_logic)
entrena <- subset(datos, !pliegue_logic)
# Definimos el modelo de la red
modelo <- nnet(form, data=entrena, size=nn_size, linout=TRUE, trace=FALSE)
# Obtenemos el nombre de la variable respuesta de la red neuronal
response_name <- setdiff(names(datos), modelo$coefnames)
# Obtenemos la respuesta pronosticada
Y_pronosticado <- predict(modelo, newdata = prueba)
rmse <- RMSE(Y_pronosticado, prueba[[response_name]])
rmse
}
n_pliegues <- 20
tamano_muestral <-300
neuronas <- 10
genera_y <- function(x){
cos(x) + rnorm(length(x), 0, 0.5)
}
X <- seq(0, 3*pi, length.out = tamano_muestral)
Y <- genera_y(X)
data.frame(X, Y) -> muestra
# Usamos la funcion createFolds para crear los pliegues
createFolds(muestra$Y, k = n_pliegues) -> pliegues
library("caret")
library("nnet")
library("parallel")
rmse_fold <- function(pliegue, form, datos,  nn_size){
# preguntamos cuales de las filas que tenemos en nuestros datos estan en el vector pliegue
pliegue_logic <- seq_len(nrow(datos)) %in% pliegue
# Definimos los sets datos
prueba <- subset(datos, pliegue_logic)
entrena <- subset(datos, !pliegue_logic)
# Definimos el modelo de la red
modelo <- nnet(form, data=entrena, size=nn_size, linout=TRUE, trace=FALSE)
# Obtenemos el nombre de la variable respuesta de la red neuronal
response_name <- setdiff(names(datos), modelo$coefnames)
# Obtenemos la respuesta pronosticada
Y_pronosticado <- predict(modelo, newdata = prueba)
rmse <- RMSE(Y_pronosticado, prueba[[response_name]])
rmse
}
n_pliegues <- 20
tamano_muestral <-300
neuronas <- 10
genera_y <- function(x){
cos(x) + rnorm(length(x), 0, 0.5)
}
X <- seq(0, 3*pi, length.out = tamano_muestral)
Y <- genera_y(X)
data.frame(X, Y) -> muestra
# Usamos la funcion createFolds para crear los pliegues
createFolds(muestra$Y, k = n_pliegues) -> pliegues
install.packages("caret")
library("caret")
#install.packages("nnet")
#install.packages("parallel")
install.packages("recipes")
install.packages("installr")
library(installr)
version
updateR()
#install.packages("nnet")
#install.packages("parallel")
install.packages("recipes")
install.packages("caret")
install.packages("recipes")
install.packages("C:/Users/VALENCIA/AppData/Local/Temp/RtmpWWinJe/downloaded_packages/recipes_1.0.10.tar.gz", repos = NULL, type = "source")
setwd("~/cursos/Curso_de_Estadistica_Inferencial_con_R/Scripts_estadistica_inferencial")
setwd("~/cursos/Curso_de_Estadistica_Inferencial_con_R/Scripts_estadistica_inferencial")
setwd("~/cursos/Curso_de_Estadistica_Inferencial_con_R/Scripts_estadistica_inferencial")
setwd("~/cursos/Curso_de_Estadistica_Inferencial_con_R/Scripts_estadistica_inferencial")
